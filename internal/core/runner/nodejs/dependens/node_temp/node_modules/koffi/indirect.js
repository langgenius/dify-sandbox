"use strict";
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// build/dist/src/cnoke/src/tools.js
var require_tools = __commonJS({
  "build/dist/src/cnoke/src/tools.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var fs2 = require("fs");
    var http = require("https");
    var path = require("path");
    var zlib = require("zlib");
    async function download_http(url, dest) {
      if (Array.isArray(url)) {
        let urls = url;
        for (let url2 of urls) {
          try {
            await download_http(url2, dest);
            return;
          } catch (err) {
            if (err.code != 404)
              throw err;
          }
        }
        throw new Error("All URLs returned error 404");
      }
      console.log(">> Downloading " + url);
      let [tmp_name, file] = open_temporary_stream(dest);
      try {
        await new Promise((resolve, reject) => {
          let request = http.get(url, (response) => {
            if (response.statusCode != 200) {
              let err = new Error(`Download failed: ${response.statusMessage} [${response.statusCode}]`);
              err.code = response.statusCode;
              reject(err);
              return;
            }
            response.pipe(file);
            file.on("finish", () => file.close(() => {
              try {
                fs2.renameSync(file.path, dest);
              } catch (err) {
                if (err.code != "EBUSY")
                  reject(err);
              }
              resolve();
            }));
          });
          request.on("error", reject);
          file.on("error", reject);
        });
      } catch (err) {
        file.close();
        try {
          fs2.unlinkSync(tmp_name);
        } catch (err2) {
          if (err2.code != "ENOENT")
            throw err2;
        }
        throw err;
      }
    }
    function open_temporary_stream(prefix) {
      let buf = Buffer.allocUnsafe(4);
      for (; ; ) {
        try {
          crypto.randomFillSync(buf);
          let suffix = buf.toString("hex").padStart(8, "0");
          let filename2 = `${prefix}.${suffix}`;
          let file = fs2.createWriteStream(filename2, { flags: "wx", mode: 420 });
          return [filename2, file];
        } catch (err) {
          if (err.code != "EEXIST")
            throw err;
        }
      }
    }
    function extract_targz(filename2, dest_dir, strip = 0) {
      let reader = fs2.createReadStream(filename2).pipe(zlib.createGunzip());
      return new Promise((resolve, reject) => {
        let header = null;
        let extended = {};
        reader.on("readable", () => {
          try {
            for (; ; ) {
              if (header == null) {
                let buf = reader.read(512);
                if (buf == null)
                  break;
                if (!buf[0])
                  continue;
                header = {
                  filename: buf.toString("utf-8", 0, 100).replace(/\0/g, ""),
                  mode: parseInt(buf.toString("ascii", 100, 109), 8),
                  size: parseInt(buf.toString("ascii", 124, 137), 8),
                  type: String.fromCharCode(buf[156])
                };
                Object.assign(header, extended);
                extended = {};
                header.filename = header.filename.replace(/\\/g, "/");
                if (!header.filename.length)
                  throw new Error(`Insecure empty filename inside TAR archive`);
                if (path_is_absolute(header.filename[0]))
                  throw new Error(`Insecure filename starting with / inside TAR archive`);
                if (path_has_dotdot(header.filename))
                  throw new Error(`Insecure filename containing '..' inside TAR archive`);
                for (let i = 0; i < strip; i++)
                  header.filename = header.filename.substr(header.filename.indexOf("/") + 1);
              }
              let aligned = Math.floor((header.size + 511) / 512) * 512;
              let data = header.size ? reader.read(aligned) : null;
              if (data == null) {
                if (header.size)
                  break;
                data = Buffer.alloc(0);
              }
              data = data.subarray(0, header.size);
              if (header.type == "0" || header.type == "7") {
                let filename3 = dest_dir + "/" + header.filename;
                let dirname = path.dirname(filename3);
                fs2.mkdirSync(dirname, { recursive: true, mode: 493 });
                fs2.writeFileSync(filename3, data, { mode: header.mode });
              } else if (header.type == "5") {
                let filename3 = dest_dir + "/" + header.filename;
                fs2.mkdirSync(filename3, { recursive: true, mode: header.mode });
              } else if (header.type == "L") {
                extended.filename = data.toString("utf-8").replace(/\0/g, "");
              } else if (header.type == "x") {
                let str = data.toString("utf-8");
                try {
                  while (str.length) {
                    let matches = str.match(/^([0-9]+) ([a-zA-Z0-9\._]+)=(.*)\n/);
                    let skip = parseInt(matches[1], 10);
                    let key = matches[2];
                    let value = matches[3];
                    switch (key) {
                      case "path":
                        {
                          extended.filename = value;
                        }
                        break;
                      case "size":
                        {
                          extended.size = parseInt(value, 10);
                        }
                        break;
                    }
                    str = str.substr(skip).trimStart();
                  }
                } catch (err) {
                  throw new Error("Malformed PAX entry");
                }
              }
              header = null;
            }
          } catch (err) {
            reject(err);
          }
        });
        reader.on("error", reject);
        reader.on("end", resolve);
      });
    }
    function path_is_absolute(path2) {
      if (process.platform == "win32" && path2.match(/^[a-zA-Z]:/))
        path2 = path2.substr(2);
      return is_path_separator(path2[0]);
    }
    function path_has_dotdot(path2) {
      let start = 0;
      for (; ; ) {
        let offset = path2.indexOf("..", start);
        if (offset < 0)
          break;
        start = offset + 2;
        if (offset && !is_path_separator(path2[offset - 1]))
          continue;
        if (offset + 2 < path2.length && !is_path_separator(path2[offset + 2]))
          continue;
        return true;
      }
      return false;
    }
    function is_path_separator(c) {
      if (c == "/")
        return true;
      if (process.platform == "win32" && c == "\\")
        return true;
      return false;
    }
    function determine_arch2() {
      let arch2 = process.arch;
      if (arch2 == "riscv32" || arch2 == "riscv64") {
        let buf = read_file_header(process.execPath, 512);
        let header = decode_elf_header(buf);
        let float_abi = (header.e_flags & 6) >> 1;
        switch (float_abi) {
          case 0:
            {
              arch2 += "sf";
            }
            break;
          case 1:
            {
              arch2 += "hf32";
            }
            break;
          case 2:
            {
              arch2 += "hf64";
            }
            break;
          case 3:
            {
              arch2 += "hf128";
            }
            break;
        }
      } else if (arch2 == "arm") {
        arch2 = "arm32";
        let buf = read_file_header(process.execPath, 512);
        let header = decode_elf_header(buf);
        if (header.e_flags & 1024) {
          arch2 += "hf";
        } else if (header.e_flags & 512) {
          arch2 += "sf";
        } else {
          throw new Error("Unknown ARM floating-point ABI");
        }
      }
      return arch2;
    }
    function read_file_header(filename2, read) {
      let fd = null;
      try {
        let fd2 = fs2.openSync(filename2);
        let buf = Buffer.allocUnsafe(read);
        let len = fs2.readSync(fd2, buf);
        return buf.subarray(0, len);
      } finally {
        if (fd != null)
          fs2.closeSync(fd);
      }
    }
    function decode_elf_header(buf) {
      let header = {};
      if (buf.length < 16)
        throw new Error("Truncated header");
      if (buf[0] != 127 || buf[1] != 69 || buf[2] != 76 || buf[3] != 70)
        throw new Error("Invalid magic number");
      if (buf[6] != 1)
        throw new Error("Invalid ELF version");
      if (buf[5] != 1)
        throw new Error("Big-endian architectures are not supported");
      let machine = buf.readUInt16LE(18);
      switch (machine) {
        case 3:
          {
            header.e_machine = "ia32";
          }
          break;
        case 40:
          {
            header.e_machine = "arm";
          }
          break;
        case 62:
          {
            header.e_machine = "amd64";
          }
          break;
        case 183:
          {
            header.e_machine = "arm64";
          }
          break;
        case 243:
          {
            switch (buf[4]) {
              case 1:
                {
                  header.e_machine = "riscv32";
                }
                break;
              case 2:
                {
                  header.e_machine = "riscv64";
                }
                break;
            }
          }
          break;
        default:
          throw new Error("Unknown ELF machine type");
      }
      switch (buf[4]) {
        case 1:
          {
            buf = buf.subarray(0, 68);
            if (buf.length < 68)
              throw new Error("Truncated ELF header");
            header.ei_class = 32;
            header.e_flags = buf.readUInt32LE(36);
          }
          break;
        case 2:
          {
            buf = buf.subarray(0, 120);
            if (buf.length < 120)
              throw new Error("Truncated ELF header");
            header.ei_class = 64;
            header.e_flags = buf.readUInt32LE(48);
          }
          break;
        default:
          throw new Error("Invalid ELF class");
      }
      return header;
    }
    function unlink_recursive(path2) {
      try {
        if (fs2.rmSync != null) {
          fs2.rmSync(path2, { recursive: true, maxRetries: process.platform == "win32" ? 3 : 0 });
        } else {
          fs2.rmdirSync(path2, { recursive: true, maxRetries: process.platform == "win32" ? 3 : 0 });
        }
      } catch (err) {
        if (err.code !== "ENOENT")
          throw err;
      }
    }
    function get_napi_version2(napi, major) {
      if (napi > 8)
        return null;
      const support = {
        6: ["6.14.2", "6.14.2", "6.14.2"],
        8: ["8.6.0", "8.10.0", "8.11.2"],
        9: ["9.0.0", "9.3.0", "9.11.0"],
        10: ["10.0.0", "10.0.0", "10.0.0", "10.16.0", "10.17.0", "10.20.0", "10.23.0"],
        11: ["11.0.0", "11.0.0", "11.0.0", "11.8.0"],
        12: ["12.0.0", "12.0.0", "12.0.0", "12.0.0", "12.11.0", "12.17.0", "12.19.0", "12.22.0"],
        13: ["13.0.0", "13.0.0", "13.0.0", "13.0.0", "13.0.0"],
        14: ["14.0.0", "14.0.0", "14.0.0", "14.0.0", "14.0.0", "14.0.0", "14.12.0", "14.17.0"],
        15: ["15.0.0", "15.0.0", "15.0.0", "15.0.0", "15.0.0", "15.0.0", "15.0.0", "15.12.0"]
      };
      const max = Math.max(...Object.keys(support).map((k) => parseInt(k, 10)));
      if (major > max)
        return major + ".0.0";
      if (support[major] == null)
        return null;
      let required = support[major][napi - 1] || null;
      return required;
    }
    function cmp_version(ver1, ver2) {
      ver1 = String(ver1).replace(/-.*$/, "").split(".").reduce((acc, v, idx) => acc + parseInt(v, 10) * Math.pow(10, 2 * (5 - idx)), 0);
      ver2 = String(ver2).replace(/-.*$/, "").split(".").reduce((acc, v, idx) => acc + parseInt(v, 10) * Math.pow(10, 2 * (5 - idx)), 0);
      let cmp = Math.min(Math.max(ver1 - ver2, -1), 1);
      return cmp;
    }
    module2.exports = {
      download_http,
      extract_targz,
      path_is_absolute,
      path_has_dotdot,
      determine_arch: determine_arch2,
      unlink_recursive,
      get_napi_version: get_napi_version2,
      cmp_version
    };
  }
});

// build/dist/src/koffi/package.json
var require_package = __commonJS({
  "build/dist/src/koffi/package.json"(exports2, module2) {
    module2.exports = {
      name: "koffi",
      version: "2.8.0",
      stable: "2.8.0",
      description: "Fast and simple C FFI (foreign function interface) for Node.js",
      keywords: [
        "foreign",
        "function",
        "interface",
        "ffi",
        "binding",
        "c",
        "napi"
      ],
      repository: {
        type: "git",
        url: "https://github.com/Koromix/koffi"
      },
      homepage: "https://koffi.dev/",
      author: {
        name: "Niels Martign\xE8ne",
        email: "niels.martignene@protonmail.com",
        url: "https://koromix.dev/"
      },
      main: "./index.js",
      types: "./index.d.ts",
      scripts: {
        test: "node tools/qemu.js test",
        prepack: `echo 'Use "npm run prepare" instead' && false`,
        prepublishOnly: `echo 'Use "npm run release" instead' && false`,
        release: "node tools/qemu.js publish"
      },
      license: "MIT",
      devDependencies: {
        chalk: "^4.1.2",
        esbuild: "^0.19.2",
        "ffi-napi": "^4.0.3",
        minimatch: "^5.0.1",
        "node-ssh": "^12.0.3",
        raylib: "^0.14.0",
        "ref-napi": "^3.0.3",
        "ref-struct-di": "^1.1.1",
        tar: "^6.1.11"
      },
      cnoke: {
        output: "build/koffi/{{ platform }}_{{ arch }}",
        napi: 8,
        require: "./index.js"
      }
    };
  }
});

// build/dist/src/koffi/indirect.js
var util = require("util");
var fs = require("fs");
var { get_napi_version, determine_arch } = require_tools();
var pkg = require_package();
if (process.versions.napi == null || process.versions.napi < pkg.cnoke.napi) {
  let major = parseInt(process.versions.node, 10);
  let required = get_napi_version(pkg.cnoke.napi, major);
  if (required != null) {
    throw new Error(`This engine is based on Node ${process.versions.node}, but ${pkg.name} requires Node >= ${required} in the Node ${major}.x branch (N-API >= ${pkg.cnoke.napi})`);
  } else {
    throw new Error(`This engine is based on Node ${process.versions.node}, but ${pkg.name} does not support the Node ${major}.x branch (N-API < ${pkg.cnoke.napi})`);
  }
}
var arch = determine_arch();
var triplet = `${process.platform}_${arch}`;
var native = null;
{
  let roots = [__dirname];
  if (process.resourcesPath != null)
    roots.push(process.resourcesPath);
  let names = [
    `/build/koffi/${process.platform}_${arch}/koffi.node`,
    `/koffi/${process.platform}_${arch}/koffi.node`,
    `/node_modules/koffi/build/koffi/${process.platform}_${arch}/koffi.node`
  ];
  for (let root of roots) {
    for (let name of names) {
      let filename = root + name;
      if (fs.existsSync(filename)) {
        native = eval("require")(filename);
        break;
      }
    }
    if (native != null)
      break;
  }
}
if (native == null)
  throw new Error("Cannot find the native Koffi module; did you bundle it correctly?");
if (native.version != pkg.version)
  throw new Error("Mismatched native Koffi modules");
module.exports = {
  ...native,
  // Deprecated functions
  handle: util.deprecate(native.opaque, "The koffi.handle() function was deprecated in Koffi 2.1, use koffi.opaque() instead", "KOFFI001"),
  callback: util.deprecate(native.proto, "The koffi.callback() function was deprecated in Koffi 2.4, use koffi.proto() instead", "KOFFI002")
};
var load = module.exports.load;
module.exports.load = (...args) => {
  let lib = load(...args);
  lib.cdecl = util.deprecate((...args2) => lib.func("__cdecl", ...args2), "The koffi.stdcall() function was deprecated in Koffi 2.7, use koffi.func(...) instead", "KOFFI003");
  lib.stdcall = util.deprecate((...args2) => lib.func("__stdcall", ...args2), 'The koffi.stdcall() function was deprecated in Koffi 2.7, use koffi.func("__stdcall", ...) instead', "KOFFI004");
  lib.fastcall = util.deprecate((...args2) => lib.func("__fastcall", ...args2), 'The koffi.fastcall() function was deprecated in Koffi 2.7, use koffi.func("__fastcall", ...) instead', "KOFFI005");
  lib.thiscall = util.deprecate((...args2) => lib.func("__thiscall", ...args2), 'The koffi.thiscall() function was deprecated in Koffi 2.7, use koffi.func("__thiscall", ...) instead', "KOFFI006");
  return lib;
};
